<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Mt. Hood, Oregon Snowfall data (2014/2015 ... 2016/2017)</title>
  <meta name="description" content="Mt. Hood, Oregon snowpack level line chart">

  <link rel="stylesheet" href="main.css" type="text/css">

  <!--google font-->
  <link href="https://fonts.googleapis.com/css?family=Alegreya+Sans" rel="stylesheet">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="script.js"></script>
</head>

<body>
  <h2 id="title">Mt. Hood Snowpack Data (2014-2015 & 2016-2017)</h2>
  <h4 id="subtitle">Elevation: 5370 feet, Site # 651</h4>
  <p>Data from Natural Resource Conservation Service</p>
  <a href="https://wcc.sc.egov.usda.gov/nwcc/site?sitenum=651"><p>More information</p></a>
  <div id="line_graph"></div>
  <script>
  //set the margins for the outer svg
  //D3 conventions for margin uses an object
  const margin = {
    left: 50,
    bottom: 40,
    right: 20,
    top: 10
  };
  const width = 900 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;
  //make a function to parse the time values
  const parseTime = d3.timeParse("%Y-%m-%d");

  //
  const x = d3.scaleTime().range([0, width]);
  //const x2 = d3.scaleTime().range([0, width]);
  //invert y range so low values will be on bottom
  const y = d3.scaleLinear().range([height,0]);

  const draw_line = d3.line()
        .x(function(d) {
          //returns a value which fits the scale for x
          return x(d.date);
        })
        //returns a value which fits the scale of y
        .y(function(d) {
          return y(d.snowlvl);
        });
  //accessor function, normalizes the data
  function normalizer(d) {
    return {
      date: d.date,
      snowlvl: +d.snowlvl
    };
  }
  function post_data(d) {
    d.date = parseTime(d.date);
    //D3 CONVENTION: use + to parseInt
    d["snowlvl"] = +d["snowlvl"];
  }
  //append svg object to the div
  const svg = d3.select("#line_graph").append("svg")
        .attr("width", width + margin.left  + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        //then append a holding group for the lines
      .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
  //read the data from the 2014-2015 csv file
  //the first anonymous function is an accessor function, and it returns the values into objects
  // d3.csv("mt_hood_2014-2015_snow.csv", normalizer, function(error, data){
  //   //error checking
  //   if(error) throw error;
  //   console.log("first set: ", data);
  //   //ensure the data is formatted
  //   data.forEach(function(d) {
  //     d.date = parseTime(d.date);
  //     //D3 CONVENTION: use + to parseInt
  //     d["snowlvl"] = +d["snowlvl"];
  //   });
  //   //define the min and max values of x and y axis (domain)
  //   x.domain(d3.extent(data, function(d) { return d.date; }));
  //   //the max y value should be the highest snow level found in the data
  //   y.domain([0, d3.max(data, function(d) { return d.snowlvl; })]);
  //
  //   //append the draw_line path to the svg wrapper
  //   svg.append("path")
  //     .data([data])
  //     .attr("class", "first_line")
  //     .attr("d", draw_line);
  //     // place x axis at bottom
  //   svg.append("g")
  //     .attr("transform", "translate(0," + height + ")")
  //     .call(d3.axisBottom(x));
  //   // place y axis on left
  //   svg.append("g")
  //     .call(d3.axisLeft(y));
  // });
  //second attempt
  //should do all the same work but within one function
  d3.queue()
    .defer(d3.csv, "mt_hood_2014-2015_snow.csv")
    .defer(d3.csv, "mt_hood_2016-2017_snow.csv")
    .await(function(error, file1, file2) {
        if (error) {
          console.error("error: " + error);
        }
        else {
          file1.forEach(function(x) {
            //normalize data (str to int for snowpack & parse date)
            normalizer(x);
            post_data(x);
          });
          // file1.forEach(function(d) {
          //   d.date = parseTime(d.date);
          //   //D3 CONVENTION: use + to parseInt
          //   d["snowlvl"] = +d["snowlvl"];
          // });
          file2.forEach(function(x) {
            normalizer(x);
            post_data(x);
          });
          // file2.forEach(function(d) {
          //   d.date = parseTime(d.date);
          //   //D3 CONVENTION: use + to parseInt
          //   d["snowlvl"] = +d["snowlvl"];
          // });
          const file1_min_date = d3.extent(file1, function(d) { return d.date; });
          const file2_max_date = d3.extent(file2, function(d) { return d.date; });
          //console.log("min: ", file1_min_date[0], "max: ", file2_max_date[1]);
          const total_domain = new Array(file1_min_date[0], file2_max_date[1]);
          console.log(total_domain);
          //define the min and max values of x and y axis (domain)
          //x.domain(d3.extent(file1, function(d) { return d.date; }));
          x.domain(total_domain);
          //x2.domain(d3.extent(file2, function(d) { return d.date; }));
          //the max y value should be the highest snow level found in the data
          y.domain([0, d3.max(file1, function(d) { return d.snowlvl; })]);

          //append the draw_line path to the svg wrapper
          svg.append("path")
            .data([file1])
            .attr("class", "first_line")
            .attr("d", draw_line);
          svg.append("path")
              .data([file2])
              .attr("class", "second_line")
              .attr("d", draw_line);
          console.log(file1)
          // place x axis at bottom
          svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
          //label the x axis
          svg.append("text")
              .attr("transform", "translate(" + (width/2) + "," + (height + margin.top + 25) + ")")
              .style("text-anchor", "middle")
              .text("Date");
          // place y axis on left
          svg.append("g")
            .call(d3.axisLeft(y));
            //make a label for y axis
            svg.append("text")
              //rotate it properly
              .attr("transform", "rotate(-90)")
              .attr("y", 0 - margin.left)
              .attr("x", 0 - (height / 2))
              .attr("dy", "1em")
              .style("text-anchor", "middle")
              .text("Snow-Water Equivlent (Inches)");
            //TODO: LEGEND
          } //end await
        });

  </script>
  <script>
  document.addEventListener("DOMContentLoaded", function(event) {
    const secondLine = d3.select(".second_line")
          .attr("transform", "translate(-750,0)");
   });
</script>
</body>

</html>
